# -*- coding: utf-8 -*-
"""Lecture 2_Sklonin_conspect.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yRGBihDGe2sbse_Qyd8WbR-dIyp_8Z15
"""

print(True and False)

print(bool(-23))

print(type(2))

print('name is Nguen Zhi\'la Kurk')

print(type(str(42)))

print(type(print))

__builtin__

print(print(22))

x = 1_000_00
print(x)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# giant = 1_000_000_000
# #%%time measures the time of excecution of the whole block
# print(giant)
# for i in range(giant):
#   pass

# Commented out IPython magic to ensure Python compatibility.
# %time #measures the time of next string execution
giant = 1_000_000_00
print(giant)
# %time
for i in range(giant):
  pass

# Commented out IPython magic to ensure Python compatibility.
# %%time
# x = 12500 ** 1000
# print(type(x))
# x

len(print(x))

len('asdfa')

len(str(print(x)))

0.1 + 0.1 + 0.1 #ебать шо

0.1 + 0.1 + 0.1 ==0.3 # ...

help(round)

round(20.0003,ndigits=10)

class Spot:
    def __init__(self, y):
      size = 1
      length = y
y = 2
y = Spot(y)
y

import this

a = int(input())
if a == 0:
  print('0')
elif a >= 0:
  print('+')
else:
  print('-')

a = int(input())
if a >= 0:
  print('+')
elif a <= 0: #this condition won't be excecuted, if  a = 0, cause it checks if a >=0 and a <0
  print('+0')

if ('adsfa'):
  print('adsfa is a bool obj and true') #well seems that it iterprets symbols as true...

if (print(32) == None): # true
  print('nothing')

help(None)

x = None
print(x is None)
print(2 is 2)
print(0 is 2)
print(None is print(2387))

print(f'x is {2} and y is {474}') # f allows to make code inside of {}
print(f'None is of type {type(None)}')

a = 1000
b = 1000
print(a is b)

c = 100
d = c
print(c is d) # is is true when two names have links to the same objects

help('is')

help(str)

s = str(4)
print(f'size of {s} is',s.__sizeof__())
print(f'len of {s}',s.__len__())
t = repr(4)
print(s,t)

r = 'asdffa'
p = r.center(11,'d') #center of length 11 between the edges, border is 'd'
print(p)
p = r.center(2, 'c') # should be error
p  #if the length (2) is less than len(p), just do nothing

r.endswith('ffda') #indicates if r is ending with this suffix

string1 = 'prime_number'
print('string1:',string1)
print(type(string1.encode()))
print('string1.encode: ', string1.encode())
print(string1)

string2 ='pripripri__prime'
string2.__ge__(string1) #prints if string2 >= string1. False cause prime_number follows prime in the dictionary

print(string1.isnumeric()) #not numeric string
print(str(1).isnumeric()) # numeric string

print(string1.capitalize())

#__count__
string2.count('prip') #how many times we can see 'prip' parts of string2 which are not overlapping?

#__rmod__
test1_str = str(32)
test1_str.__rmod__(4)

#removeprefix
test2_str = test1_str.removeprefix('2') #removes prefix if present
print(test2_str)

#split
print(test2_str.split())

test2_str.upper()

string = 'Hello'

print(string.upper(), string.lower())

string = 'string'

#string is unchangable
string[0] = 's'

type(string[0])

string = 'one and one \n two \t th ree \t four'
print(string)

#splitting
splitting_string = string.split()
print(splitting_string)

help(string.split)

#using sep in split function : sep = 'symbol' divides if sees the string in ' ' and omits it
splitting_string = string.split('\t')
print(splitting_string)

splitting_string = string.split('o')
print(splitting_string)

help(string.join)

print(string.join(splitting_string)) # string is used as glue for splitting_string sp[0]+a+sp[1]+a+...

# str.split('substring')
# 'new_substring'.join(str)
#this code will replace 'substring' with 'new_substring'

#replacement in action
test = '10100100001001011001000101'
split = test.split('0')
res = 'x'.join(split)
print(res)

#первый "а" на латинице, второй "а" на кириллице
a = list()
а = 'asdfa'
print(a,а)

#latin
type(a)

#rus
type(а)

#objects of a list are of different nature
list1 = [12,'dsaf',string.split]
print(list1)

# = is not an equality, so fractal is not created))
list1 = [1,2,3, list1]

#adding a function applied several times. append is in-place method
list1.append(list1.append)



#pop also in-place method, applied 4 times
list1.pop()

#list1 is popped
print(list1)

list1.pop(1)
print(list1)

print(list1)

#class list
#shift + enter to launch the code
help(list)

#ITERABLE CONTAINERS

for i in list1:
  print(i)

#negative indices : -1 is the last item code
print(list1[-1])

# for i in range(start,finish),
print(list1[0:0])
print(list1[0:1])

list2 = [help(list)]

type(list2[0])

list2 =['test_str']

list3 = list2[:] #copy of list2
list4 = list2 #the same obj

print(list3 is list2)
print(list4 is list2)

list2.append(3)

#list3 is a different object, list4 is list2, so it changed
print(list3,'\n',list4)

tuple1 = (1,2,3)
tuple1.append(4)

tuple1[0] = 4

#hash functions

help(hash)

hash(tuple1)

print(hash('sdf'))
'sdf'.__hash__() == hash('sdf') #__hash__ is also a magic method

#start, stop, step

list3 = []
for i in range(100):
  list3.append(i)
print(list3[0:100:2]) #start 0 stop 100 step 2

list3[::] # the full list
list3[:] #list as an array
list3 #just list
list3[:2] #elements from list3[0] to list3[1]
list3[::2] #even elements
list3[1::2] #begin with 1 el

list3[:50:6]

list3[::] == list3[0:len(list3):1] #срез = default

list4 = list3[1:40:3]
list4.index(28) #element 28 has index 9. if the element not in list, index() raized the error
print(list4[9])

'c' in 'cabd' #bool

string4 = 'c a g a b c a g a c a a f d c'
list4 = string4.split()
print(list4)
s = 0
if 'c' in list4:
  s += 1
print(s)
