# -*- coding: utf-8 -*-
"""Lecture3 .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LHZ-lnScoRuz0_g3-uJTGGaNz9FFD8xk
"""

#Lecture3 Ilia Sklonin
# ? : for asking the questions
# ! for theory
# ... well let's see what happens

list1 = list(range(100))
b = list1
c = list1[::-1] # inverse the list

print(c) # c has the same link as list1
b.append(3)
print(list1)
#list1 and b have the same link, just 2 names of the same obj

string = 'Avada Kedavra'
inv = string[::-1]
print(inv)

for i in string: #deduce : string is iterable
  print(i)

list1.reverse() #in-place method
 print(list1)

list1 = list1[:10:]
list2 = list1[::-1]
list1 + list2, list2 + list1

list1[2:5] = ['subsequence 2:5']
print(list1)

#?1 what if we do list1[2:5].reverse()?
#?2 will id(list1) change if we change list1[0]?

#?2
a = id(list1)
print(a)
list1[0] = '0'
b = id(list1)
print(b)
if a == b:
  print('id didn\'t change')

  #seems that beginning of list1 is not list1[0]

#?1
print(list1)
print(list1[0:4])
list1[0:4].reverse() # nothing happened. Probably copy
                     #of the sublist was created, not the list
                     # itself
print(list1)
print(list1[0:4])
#?3 what is list[0:4]() doing .

list2 = list1[::]
list2.clear()
print(list2)

len(list1)
list1.__len__()

#sort
list2 += list(range(10))
list2.reverse()
print(list2)
#! better not to launch code with in-place methods many times, rather reload all
#! observe idempotents H^2 = H

#sort
list2.sort()
print(list2)

help(list2.sort)

list3 = list2[:]
print(list3)
list3.sort(reverse=1) #sort descending
print(list3)

list4 = [3, 'a', range(10)]
print(list4)
list4.sort(key=str) #rise error cause range(10)
#! better create local objects in one field

#sorted()
list5 = sorted(list4, key=str) #key = function
print(list5)

#tuples
tuple1 = 3, '4', help, int, (2,3)
print(tuple1)

x = 'ab'
y = 'a' + 'b'
print(y is x)
#seems that constants have the same place in the memory

s = 1
while True:
    s += 1
    if s%2 ==0:
      continue #restart the cycle
    print(s)
    if s > 100:
      break #breaks the cycle, moves to next strings

#?4 : if we make continue in for cycle, does i increment?
#?4
for i in range(10):
  if i%2 == 0:
    i -= 2
    #continue

for i in range(10):
  if i < 0:
    break
    i += 1
else:
  print('no break worked')

help(range)

list6 = ['rain', 'clouds', 'mushrooms','loss','death','revenge','love']
for i,name in enumerate(list6):
  print(f'{i}th element is ', name)

x  = [i**2 for i in range(10) if i%2 == 0 ]
 print(*x)
# yebanutiy kod
 print(sorted([(y,x) for x in range(1,100) for y in range (x+1,100) if y % x == 0               ]))

#not clear what happened
#wow! list([0]*3) is changeable object, namely, the list. Changing one of the links in one of the lists, we change all of them!
A = [[0]*3]*3
print(A)
A[0][1] = 10
print(A)

s = ['ad']
B = [s * 5] *5
B[0][3] = ['da']
print(B)

s = list((1,2,4,5,2))
d = [s] * 5
d[0].append(232) #the same lists are just copies of links to the same object, be careful!!!
print(*d)

generator = (i**2 for i in range(10))
type(generator)













list7 = [1,3,5,6,7,54,3]
sum(list7)
max(list7)
min(list7)

def replace(string,substring,new_substring):
  lis = string.split(substring)
  st = new_substring.join(lis)
  print(st)
  return st

print(replace('My name is delusion of december and decolonization of demetrius','de','anti'))

def Чярли_Гордан(s):
  pass

